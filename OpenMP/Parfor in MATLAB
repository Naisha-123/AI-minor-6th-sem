%% Dynamic Model of the IRB 140 with Parallel Computing
clear all; close all; clc;
% Initialize parallel pool if not already running
if isempty(gcp('nocreate'))
 parpool('local');
end
%% Defining joint variables
syms q1(t) q2(t) q3(t) q4(t) q5(t) q6(t) real
syms g real
g = 9.81; % Setting gravity constant
q = [q1(t); q2(t); q3(t); q4(t); q5(t); q6(t)];
Dq = diff(q, t);
DDq = diff(Dq, t);
%% Defining link length vectors
% DH parameters for IRB 140
a = [0, 0.070, 0, 0, 0, 0]; % Link lengths
d = [0.352, 0, 0, 0.380, 0, 0.065]; % Joint offsets
alpha = [pi/2, 0, -pi/2, pi/2, -pi/2, 0]; % Link twists
% Link length vectors
r01 = [0; 0; d(1)];
r12 = [a(2); 0; 0];
r23 = [0; 0; 0];
r34 = [0; 0; d(4)];
r45 = [0; 0; 0];
r56 = [0; 0; d(6)];
% Center of mass vectors - Using provided values
r0c1 = [0; -0.03; 0.12+d(1)]; % Adding d(1) as it's in global frame
r1c2 = [0.28; 0; 0.135];
r2c3 = [0.02; 0.03; 0.1];
r3c4 = [0; 0.01; 0.05+d(4)]; % Adding d(4) as it's in global frame
r4c5 = [0; 0; 0.02];
r5c6 = [0; 0; 0.01+d(6)]; % Adding d(6) as it's in global frame
% Local COM vectors
r1c1 = r0c1 - r01;
r2c2 = r1c2 - r12;
r3c3 = r2c3 - r23;
r4c4 = r3c4 - r34;
r5c5 = r4c5 - r45;
r6c6 = r5c6 - r56;
%% Gravity vector in inertial frame
g0 = [0; 0; -g];
%% Rotation matrices
% DH convention rotation matrices
R01 = dh_rotation(q1, alpha(1), a(1), d(1));
R12 = dh_rotation(q2, alpha(2), a(2), d(2));
R23 = dh_rotation(q3, alpha(3), a(3), d(3));
R34 = dh_rotation(q4, alpha(4), a(4), d(4));
R45 = dh_rotation(q5, alpha(5), a(5), d(5));
R56 = dh_rotation(q6, alpha(6), a(6), d(6));
% Compound rotation matrices - these can be parallelized
R02 = simplify(R01 * R12);
R03 = simplify(R02 * R23);
R04 = simplify(R03 * R34);
R05 = simplify(R04 * R45);
R06 = simplify(R05 * R56);
%% Axis of rotation of joint i expressed in frame i
z0 = [0; 0; 1];
b1 = simplify(R01' * z0);
b2 = simplify(R12' * b1);
b3 = simplify(R23' * b2);
b4 = simplify(R34' * b3);
b5 = simplify(R45' * b4);
b6 = simplify(R56' * b5);
%% Link Masses - Using provided values
m1 = 9.0; % kg
m2 = 8.5; % kg
m3 = 4.8; % kg
m4 = 1.2; % kg
m5 = 1.0; % kg
m6 = 0.5; % kg
%% Inertia matrices - Using provided values
% Only diagonal elements provided, assuming zero off-diagonal elements
I1 = diag([0.1, 0.08, 0.05]); % kg·m²
I2 = diag([0.07, 0.05, 0.02]); % kg·m²
I3 = diag([0.04, 0.03, 0.01]); % kg·m²
I4 = diag([0.01, 0.01, 0.005]); % kg·m²
I5 = diag([0.005, 0.004, 0.002]); % kg·m²
I6 = diag([0.002, 0.002, 0.001]); % Estimated for link 6 based on pattern
%% Forward recursion: Link 1
% Angular velocity and acceleration
ω1 = b1 * Dq(1);
α1 = b1 * DDq(1) + cross(ω1, b1 * Dq(1));
Dω1 = diff(ω1, t);
% Linear accelerations
ac1 = cross(Dω1, r0c1) + cross(ω1, cross(ω1, r0c1));
g1 = R01' * g0;
%% Forward recursion for links 2-6
% Initialize variables to hold results
ω = cell(6,1);
α = cell(6,1);
Dω = cell(6,1);
ac = cell(6,1);
g_local = cell(6,1);
% First link already computed
ω{1} = ω1;
α{1} = α1;
Dω{1} = Dω1;
ac{1} = ac1;
g_local{1} = g1;
% Forward recursion: Link 2
ω{2} = R12' * ω{1} + b2 * Dq(2);
α{2} = R12' * α{1} + b2 * DDq(2) + cross(ω{2}, b2 * Dq(2));
Dω{2} = diff(ω{2}, t);
ac{2} = R12' * (cross(Dω{1}, r01) + cross(ω{1}, cross(ω{1}, r01))) + ...
 cross(Dω{2}, r1c2) + cross(ω{2}, cross(ω{2}, r1c2));
g_local{2} = R02' * g0;
% Forward recursion: Link 3
ω{3} = R23' * ω{2} + b3 * Dq(3);
α{3} = R23' * α{2} + b3 * DDq(3) + cross(ω{3}, b3 * Dq(3));
Dω{3} = diff(ω{3}, t);
ac{3} = R23' * (R12' * (cross(Dω{1}, r01) + cross(ω{1}, cross(ω{1}, r01))) + ...
 cross(Dω{2}, r12) + cross(ω{2}, cross(ω{2}, r12))) + ...
 cross(Dω{3}, r2c3) + cross(ω{3}, cross(ω{3}, r2c3));
g_local{3} = R03' * g0;
% Forward recursion: Link 4
ω{4} = R34' * ω{3} + b4 * Dq(4);
α{4} = R34' * α{3} + b4 * DDq(4) + cross(ω{4}, b4 * Dq(4));
Dω{4} = diff(ω{4}, t);
ac{4} = R34' * (R23' * (R12' * (cross(Dω{1}, r01) + cross(ω{1}, cross(ω{1}, r01))) + ...
 cross(Dω{2}, r12) + cross(ω{2}, cross(ω{2}, r12))) + ...
 cross(Dω{3}, r23) + cross(ω{3}, cross(ω{3}, r23))) + ...
 cross(Dω{4}, r3c4) + cross(ω{4}, cross(ω{4}, r3c4));
g_local{4} = R04' * g0;
% Forward recursion: Link 5
ω{5} = R45' * ω{4} + b5 * Dq(5);
α{5} = R45' * α{4} + b5 * DDq(5) + cross(ω{5}, b5 * Dq(5));
Dω{5} = diff(ω{5}, t);
ac{5} = R45' * (R34' * (R23' * (R12' * (cross(Dω{1}, r01) + cross(ω{1}, cross(ω{1}, r01))) + ...
 cross(Dω{2}, r12) + cross(ω{2}, cross(ω{2}, r12))) + ...
 cross(Dω{3}, r23) + cross(ω{3}, cross(ω{3}, r23))) + ...
 cross(Dω{4}, r34) + cross(ω{4}, cross(ω{4}, r34))) + ...
 cross(Dω{5}, r4c5) + cross(ω{5}, cross(ω{5}, r4c5));
g_local{5} = R05' * g0;
% Forward recursion: Link 6
ω{6} = R56' * ω{5} + b6 * Dq(6);
α{6} = R56' * α{5} + b6 * DDq(6) + cross(ω{6}, b6 * Dq(6));
Dω{6} = diff(ω{6}, t);
ac{6} = R56' * (R45' * (R34' * (R23' * (R12' * (cross(Dω{1}, r01) + cross(ω{1}, cross(ω{1},
r01))) + ...
 cross(Dω{2}, r12) + cross(ω{2}, cross(ω{2}, r12))) + ...
 cross(Dω{3}, r23) + cross(ω{3}, cross(ω{3}, r23))) + ...
 cross(Dω{4}, r34) + cross(ω{4}, cross(ω{4}, r34))) + ...
 cross(Dω{5}, r45) + cross(ω{5}, cross(ω{5}, r45))) + ...
 cross(Dω{6}, r5c6) + cross(ω{6}, cross(ω{6}, r5c6));
g_local{6} = R06' * g0;
% Now unpack the results
ω2 = ω{2};
ω3 = ω{3};
ω4 = ω{4};
ω5 = ω{5};
ω6 = ω{6};
α2 = α{2};
α3 = α{3};
α4 = α{4};
α5 = α{5};
α6 = α{6};
Dω2 = Dω{2};
Dω3 = Dω{3};
Dω4 = Dω{4};
Dω5 = Dω{5};
Dω6 = Dω{6};
ac2 = ac{2};
ac3 = ac{3};
ac4 = ac{4};
ac5 = ac{5};
ac6 = ac{6};
g2 = g_local{2};
g3 = g_local{3};
g4 = g_local{4};
g5 = g_local{5};
g6 = g_local{6};
%% Backward recursion
% Initialize variables to hold torque results
f = cell(6,1);
τ = cell(6,1);
τDyn = cell(6,1);
% Backward recursion: Link 6
f{6} = m6 * ac6 - m6 * g6;
τ{6} = -cross(f{6}, r5c6) + I6 * α6 + cross(ω6, I6 * ω6);
τDyn{6} = simplify(b6' * τ{6});
% Backward recursion for remaining links
% Link 5
f{5} = R56 * f{6} + m5 * ac5 - m5 * g5;
τ{5} = R56 * τ{6} - cross(f{5}, r4c5) + cross(R56 * f{6}, r5c5) + I5 * α5 + cross(ω5, I5 * ω5);
τDyn{5} = simplify(b5' * τ{5});
% Link 4
f{4} = R45 * f{5} + m4 * ac4 - m4 * g4;
τ{4} = R45 * τ{5} - cross(f{4}, r3c4) + cross(R45 * f{5}, r4c4) + I4 * α4 + cross(ω4, I4 * ω4);
τDyn{4} = simplify(b4' * τ{4});
% Link 3
f{3} = R34 * f{4} + m3 * ac3 - m3 * g3;
τ{3} = R34 * τ{4} - cross(f{3}, r2c3) + cross(R34 * f{4}, r3c3) + I3 * α3 + cross(ω3, I3 * ω3);
τDyn{3} = simplify(b3' * τ{3});
% Link 2
f{2} = R23 * f{3} + m2 * ac2 - m2 * g2;
τ{2} = R23 * τ{3} - cross(f{2}, r1c2) + cross(R23 * f{3}, r2c2) + I2 * α2 + cross(ω2, I2 * ω2);
τDyn{2} = simplify(b2' * τ{2});
% Link 1
f{1} = R12 * f{2} + m1 * ac1 - m1 * g1;
τ{1} = R12 * τ{2} - cross(f{1}, r0c1) + cross(R12 * f{2}, r1c1) + I1 * α1 + cross(ω1, I1 * ω1);
τDyn{1} = simplify(b1' * τ{1});
% Collect results
τ1Dyn = τDyn{1};
τ2Dyn = τDyn{2};
τ3Dyn = τDyn{3};
τ4Dyn = τDyn{4};
τ5Dyn = τDyn{5};
τ6Dyn = τDyn{6};
%% Setting up the matrix elements - this part can be parallelized efficiently
% Calculate Mass Matrix
M = zeros(6, 6);
subs_zero = [Dq(1) 0 Dq(2) 0 Dq(3) 0 Dq(4) 0 Dq(5) 0 Dq(6) 0 g 9.81];
% Using parfor to parallelize the outer loop
parfor i = 1:6
 M_row = zeros(1, 6);
 for j = 1:6
 % Set up acceleration vector with only one non-zero entry
 subs_acc = zeros(1, 12);
 for k = 1:6
 if k == j
 subs_acc(2*k-1:2*k) = [DDq(k) 1];
 else
 subs_acc(2*k-1:2*k) = [DDq(k) 0];
 end
 end

 % Extract mass matrix element
 switch i
 case 1
 M_row(j) = subs(τ1Dyn, [subs_zero subs_acc]);
 case 2
 M_row(j) = subs(τ2Dyn, [subs_zero subs_acc]);
 case 3
 M_row(j) = subs(τ3Dyn, [subs_zero subs_acc]);
 case 4
 M_row(j) = subs(τ4Dyn, [subs_zero subs_acc]);
 case 5
 M_row(j) = subs(τ5Dyn, [subs_zero subs_acc]);
 case 6
 M_row(j) = subs(τ6Dyn, [subs_zero subs_acc]);
 end
 end
 M(i,:) = M_row;
end
% Calculate gravity vector in parallel
G = zeros(6, 1);
subs_zero_acc = [DDq(1) 0 DDq(2) 0 DDq(3) 0 DDq(4) 0 DDq(5) 0 DDq(6) 0 ...
 Dq(1) 0 Dq(2) 0 Dq(3) 0 Dq(4) 0 Dq(5) 0 Dq(6) 0];
% Using parallel computation for gravity vector
parfor i = 1:6
 switch i
 case 1
 G(i) = subs(τ1Dyn, subs_zero_acc);
 case 2
 G(i) = subs(τ2Dyn, subs_zero_acc);
 case 3
 G(i) = subs(τ3Dyn, subs_zero_acc);
 case 4
 G(i) = subs(τ4Dyn, subs_zero_acc);
 case 5
 G(i) = subs(τ5Dyn, subs_zero_acc);
 case 6
 G(i) = subs(τ6Dyn, subs_zero_acc);
 end
end
%% Setting up the dynamic system
% Assemble the final dynamics
τD = [τ1Dyn; τ2Dyn; τ3Dyn; τ4Dyn; τ5Dyn; τ6Dyn];
% Calculate Coriolis and centrifugal terms
C_Dq = simplify(τD - M * [DDq(1); DDq(2); DDq(3); DDq(4); DDq(5); DDq(6)] - G);
%% Kinetic energy
% Calculate the total kinetic energy
KE = 0;
for i = 1:6
 for j = 1:6
 KE = KE + 0.5 * M(i,j) * Dq(i) * Dq(j);
 end
end
KE = simplify(KE);
%% Save matrices for further analysis
save('IRB140_dynamics_matrices.mat', 'M', 'C_Dq', 'G', 'KE');
%% Matlab conversion
% Generate MATLAB function for numerical computation
matlabFunction([M, C_Dq, G], 'File', 'IRB140_dynamics_numerical', 'Vars', {q, Dq});
%% Helper function for DH transformation
function R = dh_rotation(theta, alpha, a, d)
 ct = cos(theta);
 st = sin(theta);
 ca = cos(alpha);
 sa = sin(alpha);

 R = [ct, -st*ca, st*sa;
 st, ct*ca, -ct*sa;
 0, sa, ca];
end
%% Add simulation functionality
% Joint trajectories for simulation
function [q_traj, dq_traj, ddq_traj] = generate_trajectories(t)
 % Define simple sinusoidal trajectories for testing
 q_traj = [
 0.5*sin(t);
 0.3*sin(t + pi/4);
 0.2*sin(t + pi/3);
 0.4*sin(t + pi/2);
 0.3*sin(t + 2*pi/3);
 0.2*sin(t + 3*pi/4)
 ];

 % Derivatives
 dq_traj = [
 0.5*cos(t);
 0.3*cos(t + pi/4);
 0.2*cos(t + pi/3);
 0.4*cos(t + pi/2);
 0.3*cos(t + 2*pi/3);
 0.2*cos(t + 3*pi/4)
 ];

 ddq_traj = [
 -0.5*sin(t);
 -0.3*sin(t + pi/4);
 -0.2*sin(t + pi/3);
 -0.4*sin(t + pi/2);
 -0.3*sin(t + 2*pi/3);
 -0.2*sin(t + 3*pi/4)
 ];
end
%% Test the dynamics with sample joint trajectories
function test_dynamic_model()
 % Time vector
 t_span = 0:0.01:5;
 torques = zeros(6, length(t_span));

 % Simulate for each time step
 for i = 1:length(t_span)
 [q_traj, dq_traj, ddq_traj] = generate_trajectories(t_span(i));

 % Load dynamic matrices from the generated function
 [M, C_Dq, G] = IRB140_dynamics_numerical(q_traj, dq_traj);

 % Calculate torques
 torques(:,i) = M * ddq_traj + C_Dq + G;
 end

 % Plot results
 figure;
 for i = 1:6
 subplot(3,2,i);
 plot(t_span, torques(i,:));
 title(['Joint ', num2str(i), ' Torque']);
 xlabel('Time (s)');
 ylabel('Torque (N·m)');
 grid on;
 end

 % Save figure
 saveas(gcf, 'IRB140_joint_torques.png');
end
